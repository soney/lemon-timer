{"version":3,"sources":["EditableTextField.tsx","IntervalConfig.tsx","Timer.tsx","App.tsx","LemonIcon.tsx","TaskDisplay.tsx","index.tsx"],"names":["STATE","IntervalConfigDisplay","initialWorkInterval","workInterval","initialBreakInterval","breakInterval","onChangeWorkInterval","onChangeBreakInterval","useState","setWorkInterval","setBreakInterval","className","htmlFor","min","max","type","id","value","onChange","ev","newValue","parseInt","target","EditableTextField","placeholder","editing","editable","editingClassName","viewingClassName","onValueChange","onFinishChange","onStartEditing","onStopEditing","EDITING","VIEWING","currentState","setState","beforeEditValue","setBeforeEditValue","currentValue","setValue","inputRef","useRef","useEffect","current","focus","select","onDoneEditing","cancelled","classNames","onKeyDown","key","onBlur","ref","usePlaceholder","trim","disabled","onClick","millisecondsToHumanString","ms","totalSeconds","Math","round","minutes","floor","toString","padStart","seconds","CountdownTimerDisplay","STOP_REASON","onDone","Date","now","remaining","setRemaining","updateInterval","setInterval","timeLeft","clearInterval","LemonIcon","blinking","solid","setSolid","interval","s","TaskDisplay","task","onRemove","onDescriptionChange","onStart","workOnUntil","onStop","currentlyEditing","setCurrentlyEditing","lemonIcons","times","completedIntervals","idx","style","minWidth","description","desc","onMouseDown","width","length","COMPLETED","USER_INTERRUPT","invisible","MTaskDisplay","React","memo","pingAudio","Audio","editingTaskUid","App","initialState","state","onStateChange","addTask","useCallback","maxExistingID","tasks","map","t","newTask","update","$push","startTask","workingUntil","activeTaskID","$set","stopTask","reason","play","taskIndex","getTaskIndex","breakUntil","onBreakUntil","$apply","c","removeTask","$splice","setTaskDescription","newWorkInterval","newBreakInterval","stopBreak","currentlyWorking","currentlyOnBreak","currentlyIdle","taskElements","isActiveTask","working","colSpan","IntervalConfig","DEFAULT_TITLE","LOCAL_STORAGE_KEY","DEFAULT_APP_STATE","MApp","Root","data","localStorage","getItem","JSON","parse","loadState","setAppState","title","setTitle","humanReadableRemaining","taskDescription","newState","setItem","stringify","saveState","Helmet","ReactDOM","render","document","getElementById"],"mappings":"iJAUKA,E,8DCiCUC,EA9B8C,SAAC,GAA4H,IAA7GC,EAA4G,EAA1HC,aAAkDC,EAAwE,EAAvFC,cAAqCC,EAAkD,EAAlDA,qBAAsBC,EAA4B,EAA5BA,sBACzJ,EAA0CC,mBAASN,GAAnD,mBAAOC,EAAP,KAAsBM,EAAtB,KACA,EAA0CD,mBAASJ,GAAnD,mBAAOC,EAAP,KAAsBK,EAAtB,KAcA,OAAO,uBAAMC,UAAU,kBAAhB,UACK,qBAAKA,UAAU,aACf,sBAAKA,UAAU,WAAf,UACI,uBAAOC,QAAQ,WAAf,sCACA,uBAAOD,UAAU,eAAeE,IAAK,EAAGC,IAAK,IAAMC,KAAK,SAASC,GAAG,WAAWC,MAAOd,GAAc,GAAIe,SAhB3F,SAACC,GAC1B,IAAMC,EAAWC,SAASF,EAAGG,OAAOL,OACpCR,EAAgBW,GAChBd,EAAqBc,SAeb,sBAAKT,UAAU,WAAf,UACI,uBAAOC,QAAQ,YAAf,uCACA,uBAAOD,UAAU,eAAeE,IAAK,EAAGC,IAAK,IAAMC,KAAK,SAASC,GAAG,YAAYC,MAAOZ,GAAe,GAAIa,SAd5F,SAACC,GAC3B,IAAMC,EAAWC,SAASF,EAAGG,OAAOL,OACpCP,EAAiBU,GACjBb,EAAsBa,SAad,qBAAKT,UAAU,iB,0BD7B1BX,O,qBAAAA,I,sBAAAA,M,KAeL,IA6DeuB,EA7D6C,SAAC,GAAyJ,IAAxJN,EAAuJ,EAAvJA,MAAOO,EAAgJ,EAAhJA,YAAaC,EAAmI,EAAnIA,QAASC,EAA0H,EAA1HA,SAAUC,EAAgH,EAAhHA,iBAAkBC,EAA8F,EAA9FA,iBAA4BC,EAAkE,EAA5EX,SAAyBY,EAAmD,EAAnDA,eAAgBC,EAAmC,EAAnCA,eAAgBC,EAAmB,EAAnBA,cAC9L,EAAiCxB,mBAAgBiB,EAAUzB,EAAMiC,QAAUjC,EAAMkC,SAAjF,mBAAOC,EAAP,KAAqBC,EAArB,KACA,EAA8C5B,mBAAiBS,GAAO,IAAtE,mBAAOoB,EAAP,KAAwBC,EAAxB,KACA,EAAiC9B,mBAAiBS,GAAO,IAAzD,mBAAOsB,EAAP,KAAqBC,EAArB,KACMC,EAAWC,iBAAyB,MAW1C,GATAC,qBAAU,WACHR,IAAiBnC,EAAMiC,SACnBQ,EAASG,UACRH,EAASG,QAAQC,QACjBJ,EAASG,QAAQE,YAG1B,CAACX,IAEDA,IAAiBnC,EAAMiC,QAAS,CAE/B,IAOMc,EAAgB,WAA8B,IAA7BC,EAA4B,wDAC/CZ,EAASpC,EAAMkC,SACZF,GAAkBA,IAElBgB,GACCR,EAASH,GACNP,GAAkBA,EAAeO,IAEjCP,GAAkBA,EAAeS,IAa5C,OAAO,uBAAO5B,UAAWsC,IAAWtB,GAAmBZ,KAAK,OAAOE,MAAOsB,EAAcW,UARtE,SAAC/B,GACD,UAAXA,EAAGgC,IACFJ,IACiB,QAAX5B,EAAGgC,KACTJ,GAAc,IAIwF7B,SA5B7F,SAACC,GACd,IAAMC,EAAWD,EAAGG,OAAOL,MAC3BuB,EAASpB,GACNS,GAAiBA,EAAcT,IAyB4FgC,OATnH,kBAAML,KAS6HvB,YAAaA,EAAa6B,IAAKZ,IAGjL,IAOMa,GAAkBf,EAAagB,OAErC,OAAO,wBAAQC,UAAW9B,EAAUf,UAAWsC,IAAW,MAAO,WAAYrB,EAAkB,CAACJ,YAAa8B,IAAkBG,QAT/G,WACT/B,IACCU,EAASpC,EAAMiC,SACfK,EAAmBC,GAChBR,GAAmBA,MAKvB,SAA2IuB,EAAkB9B,GAAe,UAAae,K,QElDjM,SAASmB,EAA0BC,GACtC,IAAMC,EAAeC,KAAKC,MAAMH,EAAG,KAE7BI,EAAUF,KAAKG,MAAMJ,EAAa,IAAIK,WAAWC,SAAS,EAAG,KAC7DC,GAAWP,EAAa,IAAIK,WAAWC,SAAS,EAAG,KACzD,MAAM,GAAN,OAAUH,EAAV,YAAqBI,GAGVC,ICzBHC,EDyBGD,EAjCqD,SAAC,GAAsB,IAArB9C,EAAoB,EAApBA,OAAQgD,EAAY,EAAZA,OAC1E,EAAkC9D,mBAAiBc,EAASiD,KAAKC,OAAjE,mBAAOC,EAAP,KAAkBC,EAAlB,KAeA,OAdA/B,qBAAU,WACN,IAAMgC,EAAiBC,aAAY,WAC/B,IAAMC,EAAWvD,EAASiD,KAAKC,MAC/BE,EAAaG,GAEVA,GAAY,IACXC,cAAcH,GACdL,OAEL,KAEH,OAAO,kBAAMQ,cAAcH,MAC5B,IAEI,mCAAGjB,EAA0Be,MEFzBM,EAd6B,SAAC,GAAgB,IAAfC,EAAc,EAAdA,SAC1C,EAA0BxE,oBAAkB,GAA5C,mBAAOyE,EAAP,KAAcC,EAAd,KAWA,OATAvC,qBAAU,WACN,GAAGqC,EAAU,CACT,IAAMG,EAAWP,aAAY,WACzBM,GAAS,SAACE,GAAD,OAAQA,OAClB,KACH,OAAO,WAAQN,cAAcK,OAElC,CAACH,IAEG,mBAAGrE,UAAWsC,IAAW,QAAS,WAAYgC,EAAQ,WAAa,iBC4B/DI,EAvB0B,SAAC,GAA4F,IAA3FC,EAA0F,EAA1FA,KAAM7D,EAAoF,EAApFA,QAAS8D,EAA2E,EAA3EA,SAAUC,EAAiE,EAAjEA,oBAAqBC,EAA4C,EAA5CA,QAASC,EAAmC,EAAnCA,YAAahE,EAAsB,EAAtBA,SAAUiE,EAAY,EAAZA,OACrH,EAAgDnF,mBAAkBiB,GAAlE,mBAAOmE,EAAP,KAAyBC,EAAzB,KACMC,EAAaC,gBAAMT,EAAKU,oBAAoB,SAACC,GAAD,OAAS,cAAC,EAAD,CAAWjB,UAAU,GAAYiB,MAE5F,OAAO,qBAAItF,UAAW,QAAU+E,EAAc,UAAY,IAAnD,UACH,qBAAI/E,UAAU,cAAcuF,MAAO,CAACC,SAAU,QAA9C,UACI,cAAC,EAAD,CAAmBzE,SAAUA,EAAUK,eAAgB,kBAAM8D,GAAoB,IAAO7D,cAAe,kBAAM6D,GAAoB,IAAQlE,iBAAkB,eAAgBV,MAAOqE,EAAKc,YAAa3E,QAASA,EAASD,YAAY,mBAAmBM,eAAgB,SAACuE,GAAD,OAAUb,EAAoBF,EAAKtE,GAAIqF,MAC3ST,GAAoB,wBAAQjF,UAAU,gCAAgC2F,YAAa,kBAAMf,EAASD,EAAKtE,KAAnF,SAAwF,mBAAGL,UAAU,iCAE9H,oBAAIA,UAAU,8BAA8BuF,MAAO,CAACK,MAAO,QAA3D,SACI,sBAAK5F,UAAU,OAAf,UACKmF,EACAJ,GAAe,qCAAE,cAAC,EAAD,CAAWV,UAAU,GAAWc,EAAWU,QAA7C,OAA6D,sBAAM7F,UAAU,cAAhB,SAA8B,cAAC,EAAD,CAAuBW,OAAQoE,EAAapB,OAAQ,kBAAMqB,EAAOL,EAAKtE,GAAIqD,EAAYoC,wBAGzM,qBAAI9F,UAAU,SAASuF,MAAO,CAACK,MAAO,QAAtC,UACKb,GAAgB,yBAAQ/E,UAAU,mCAAoC8C,QAAS,kBAAMkC,EAAOL,EAAKtE,GAAIqD,EAAYqC,iBAAjG,UAAkH,mBAAG/F,UAAU,qBAA/H,eACf+E,GAAe,yBAAQ/E,UAAWsC,IAAW,MAAO,sBAAuB,YAAa,CAAC0D,WAAYjF,IAAY+B,QAAS,kBAAMgC,EAAQH,EAAKtE,KAA9H,UAAmI,mBAAGL,UAAU,qBAAhJ,sB,gBF5BvBiG,EAAeC,IAAMC,KAAKzB,I,SAEpBhB,O,mCAAAA,I,0BAAAA,M,KAqBZ,IAAM0C,EAAY,IAAIC,MAAM,YAGxBC,GAA+B,EAkIpBC,EAjIiB,SAAC,GAA4C,IAAnCC,EAAkC,EAAzCC,MAAqBC,EAAoB,EAApBA,cACpD,EAA0B7G,mBAAmB2G,GAA7C,mBAAOC,EAAP,KAAchF,EAAd,KAEAO,qBAAU,WACH0E,GACCA,EAAcD,KAEnB,CAACA,IAEJ,IAAME,EAAUT,IAAMU,aAAY,WAC9BnF,GAAS,SAACgF,GAEN,IAAMI,EAAgB3D,KAAK/C,IAAL,MAAA+C,KAAI,CAAK,GAAL,mBAAWuD,EAAMK,MAAMC,KAAI,SAACC,GAAD,OAAOA,EAAE3G,SAGxD4G,EAAgB,CAAC5G,GAFZiG,EAAiBO,EAAgB,EAEjBpB,YAAa,GAAIJ,mBAAoB,GAChE,OAAO6B,IAAOT,EAAO,CAAEK,MAAO,CAACK,MAAO,CAACF,WAE5C,IAEGG,EAAYlB,IAAMU,aAAY,SAACvG,GACjCoB,GAAS,SAACgF,GACN,IAAMY,EAAezD,KAAKC,MAnDhB,KAmDyB4C,EAAMjH,cAAc,GACvD,OAAO0H,IAAOT,EAAO,CAAEa,aAAc,CAACC,KAAMlH,GAAKgH,aAAc,CAACE,KAAMF,UAE3E,IAEGG,EAAWtB,IAAMU,aAAY,SAACvG,EAAYoH,GAC5ChG,GAAS,SAACgF,GACN,GAAGgB,IAAW/D,EAAYoC,UAAW,CACjCM,EAAUsB,OACV,IAAMC,EAAYC,EAAanB,EAAMK,MAAOzG,GAC5C,IAAe,IAAZsH,EAAmB,CAElB,IAAME,EAAajE,KAAKC,MA/DtB,KA+D+B4C,EAAM/G,eAAe,GACtD,OAAOwH,IAAOT,EAAO,CAAEa,aAAc,CAACC,MAAM,GAAQF,aAAc,CAACE,MAAM,GAAQO,aAAc,CAACP,KAAMM,GAAaf,MAAM,eAAIa,EAAY,CAAEtC,mBAAoB,CAAC0C,OAAQ,SAACC,GAAD,OAAOA,EAAE,SAIzL,OAAOd,IAAOT,EAAO,CAAEa,aAAc,CAACC,MAAM,GAAQF,aAAc,CAACE,MAAM,UAE9E,IAEGU,EAAa/B,IAAMU,aAAY,SAACvG,GAClCoB,GAAS,SAACgF,GACN,IAAMkB,EAAYC,EAAanB,EAAMK,MAAOzG,GAC5C,OAAe,IAAZsH,EACQT,IAAOT,EAAO,CAACK,MAAO,CAACoB,QAAS,CAAC,CAACP,EAAW,OAE7ClB,OAGhB,IAEG0B,EAAqBjC,IAAMU,aAAY,SAACvG,EAAYoF,GACtDhE,GAAS,SAACgF,GACN,IAAMkB,EAAYC,EAAanB,EAAMK,MAAOzG,GAC5C,OAAe,IAAZsH,EACQT,IAAOT,EAAO,CAACK,MAAM,eAAGa,EAAY,CAAElC,YAAa,CAAC8B,KAAM9B,OAE1DgB,OAGhB,IAEG3G,EAAkBoG,IAAMU,aAAY,SAACwB,GACvC3G,GAAS,SAACgF,GACN,OAAOS,IAAOT,EAAO,CAACjH,aAAc,CAAC+H,KAAMa,UAEhD,IAEGrI,EAAmBmG,IAAMU,aAAY,SAACyB,GACxC5G,GAAS,SAACgF,GACN,OAAOS,IAAOT,EAAO,CAAC/G,cAAe,CAAC6H,KAAMc,UAEjD,IAEGC,EAAY,SAACb,GACfhG,GAAS,SAACgF,GAIN,OAHGgB,IAAW/D,EAAYoC,WACtBM,EAAUsB,OAEPR,IAAOT,EAAO,CAACqB,aAAc,CAACP,MAAM,SAI7CgB,GAA0C,IAAvB9B,EAAMa,aACzBkB,GAA0C,IAAvB/B,EAAMqB,aACzBW,GAAoBF,IAAqBC,EAEzCE,EAAejC,EAAMK,MAAMC,KAAI,SAACC,GAClC,IAAM2B,EAAe3B,EAAE3G,KAAOoG,EAAMa,aAC9BvG,GAAiC,IAArB0F,EAAMa,eAAiD,IAAvBb,EAAMqB,aACxD,OAAO,cAAC7B,EAAD,CAAyBjB,OAAQwC,EAAU1C,QAASsC,EAAWzC,KAAMqC,EAAGlG,QAASkG,EAAE3G,KAAKiG,EAAgB1B,SAAUqD,EAAYpD,oBAAqBsD,EAAoBpD,YAAa4D,GAAgBlC,EAAMY,aAActG,SAAUA,GAA/MiG,EAAE3G,OAIhC,OAFAiG,GAAiB,EAEV,qCACP,sBAAMtG,UAAU,YAAhB,SACI,wBAAOK,GAAG,YAAYL,UAAWsC,IAAW,QAAS,CAACsG,QAASL,IAA/D,UACI,gCACI,6BACI,qBAAIM,QAAS,EAAG7I,UAAasC,IAAW,CAAC0D,UAAWuC,IAApD,WACMC,GAAqB,yDACtB/B,EAAMqB,cAAgB,kDACf,cAAC,EAAD,CAAuBnH,OAAQ8F,EAAMqB,aAAcnE,OAAQ,kBAAM2E,EAAU5E,EAAYoC,cADxE,OAEf,yBAAQ9F,UAAU,mCAAoC8C,QAAS,kBAAMwF,EAAU5E,EAAYqC,iBAA3F,UAA4G,mBAAG/F,UAAU,qBAAzH,6BAKpB,iCAASwI,GAAoBE,IAC7B,gCACI,6BACI,oBAAIG,QAAS,EAAb,SACI,qBAAK7I,UAAU,SAAf,SACKyI,GAAiB,yBAAQzI,UAAU,4BAA4B6C,UAA+B,IAArB4D,EAAMa,aAAsBxE,QAAS6D,EAA7F,UAAsG,mBAAG3G,UAAU,qBAAnH,+BAO1C,wBAAQA,UAAU,YAAlB,SACKyI,GAAiB,cAACK,EAAD,CAAuBtJ,aAAciH,EAAMjH,aAAcE,cAAe+G,EAAM/G,cAAeC,qBAAsBG,EAAiBF,sBAAuBG,UAc9K,SAAS6H,EAAad,EAAoBzG,GAC7C,IAAI,IAAIiF,EAAc,EAAGA,EAAIwB,EAAMjB,OAAQP,IACvC,GAAGwB,EAAMxB,GAAKjF,KAAOA,EACjB,OAAOiF,EAGf,OAAO,E,8BG5KLyD,EAAgB,cAChBC,EAAoB,cAGpBC,EAA8B,CAChCnC,MAAO,GAAIQ,cAAc,EAAOD,cAAc,EAAOS,cAAc,EACnEtI,aAAc,GAAIE,cAAe,GAuBrC,IAAMwJ,EAAOhD,IAAMC,KAAKI,GAExB,SAAS4C,IACL,MAA6BtJ,mBAhBjC,WACI,IACI,IAAMuJ,EAAOC,aAAaC,QAAQN,GAClC,QAAGI,GACQG,KAAKC,MAAMJ,GAIxB,SACE,OAAO,GAOqCK,IAAeR,GAA/D,mBAAOxC,EAAP,KAAciD,EAAd,KACA,EAA0B7J,mBAAiBkJ,GAA3C,mBAAOY,EAAP,KAAcC,EAAd,KAEA5H,qBAAU,WACN,IAAMgC,EAAiBC,aAAY,WAC/B,IAA0B,IAAvBwC,EAAMY,eAAiD,IAAvBZ,EAAMa,aAAwB,CAC7D,IACMuC,EAAyB9G,EADb0D,EAAMY,aAAezD,KAAKC,OAGtC8D,EAAYC,EAAanB,EAAMK,MAAOL,EAAMa,cAC5CwC,GAAgC,IAAdnC,EAAsB,QAAUlB,EAAMK,MAAMa,GAAWlC,YAC/EmE,EAAS,GAAD,OAAIC,EAAJ,cAAgCC,SACrC,IAA0B,IAAvBrD,EAAMqB,aAAwB,CACpC,IAAMhE,EAAY2C,EAAMqB,aAAelE,KAAKC,MAC5C+F,EAAS,GAAD,OAAI7G,EAA0Be,GAA9B,kBAEL6F,IAAUZ,GACTa,EAASb,KAGlB,KAEH,OAAO,kBAAM5E,cAAcH,MAC5B,CAACyC,IAEJ,IAAMC,EAAgBR,IAAMU,aAAY,SAACmD,GACrCL,EAAYK,GA/CpB,SAAmBtD,GACf4C,aAAaW,QAAQhB,EAAmBO,KAAKU,UAAUxD,IA+CnDyD,CAAUH,KACX,IAEH,OAAO,qCACH,cAACI,EAAA,EAAD,UAAQ,gCAAQR,MAChB,cAACT,EAAD,CAAMxC,cAAeA,EAAeD,MAAOA,OAInD2D,IAASC,OAAO,cAAClB,EAAD,IAAUmB,SAASC,eAAe,W","file":"static/js/main.1b6812d5.chunk.js","sourcesContent":["import React, { useEffect, useRef, useState } from \"react\";\r\nimport classNames from \"classnames\";\r\n\r\n/**\r\n * An EditableTextField is a button that you can push in order to edit the content.\r\n * When editing its content, it appears as a text input. After the user hits [Enter]\r\n * or clicks away from the input, it reverts back to a button whose content is\r\n * what the user just entered.\r\n */\r\n\r\nenum STATE { EDITING, VIEWING}; // the state of a given editable text field\r\n\r\ntype EditableTextFieldProps = {\r\n    placeholder?: string,                         // What should appear when the input field is empty\r\n    value?: string,                               // The current value\r\n    editing?: boolean,                            // If set to `true`, will start out editing\r\n    editingClassName?: string,                    // HTML class names that our component should have while editing\r\n    viewingClassName?: string,                    // HTML class names that our component should have while viewing\r\n    editable?: boolean,                           // `false` if the user should **not** be able to edit the content\r\n    onChange?: (newValue: string) => void,        // A callback to be called as the user edits (keystroke level)\r\n    onFinishChange?: (newValue: string) => void   // A callback to be called when the user finishes editing (when the <input /> disappears)\r\n    onStartEditing?: () => void                   // A callback to be called when the user begins editing\r\n    onStopEditing?: () => void                    // A callback to be called when the user finishes editing\r\n}\r\n\r\nconst EditableTextField: React.FC<EditableTextFieldProps> = ({value, placeholder, editing, editable, editingClassName, viewingClassName, onChange: onValueChange, onFinishChange, onStartEditing, onStopEditing}) => {\r\n    const [currentState, setState] = useState<STATE>(editing ? STATE.EDITING : STATE.VIEWING); // Represents the current state (editing or viewing)\r\n    const [beforeEditValue, setBeforeEditValue] = useState<string>(value||'');                 // Represents the current value **before** the user started editing (in case we need to revert when the user hits Esc)\r\n    const [currentValue, setValue] = useState<string>(value||'');                              // Represents the current value\r\n    const inputRef = useRef<HTMLInputElement>(null);    // A reference to the <input /> element\r\n\r\n    useEffect(() => { // When we begin editing, focus and select the <input /> element\r\n        if(currentState === STATE.EDITING) {\r\n            if(inputRef.current) {\r\n                inputRef.current.focus();\r\n                inputRef.current.select();\r\n            }\r\n        }\r\n    }, [currentState]);\r\n\r\n    if(currentState === STATE.EDITING) {\r\n        // When the user changes the input value\r\n        const onChange = (ev: React.ChangeEvent<HTMLInputElement>) => {\r\n            const newValue = ev.target.value;\r\n            setValue(newValue);\r\n            if(onValueChange) { onValueChange(newValue); }\r\n        };\r\n\r\n        // When the user is done editing. If they cancelled, revert back to the old value\r\n        const onDoneEditing = (cancelled:boolean=false) => {\r\n            setState(STATE.VIEWING);\r\n            if(onStopEditing)  { onStopEditing(); }\r\n\r\n            if(cancelled) { // If the user cancelled, then revert to the old value (before we started editing)\r\n                setValue(beforeEditValue);\r\n                if(onFinishChange) { onFinishChange(beforeEditValue); }\r\n            } else { // If the user didn't cancel, notify that we finished editing with the new value\r\n                if(onFinishChange) { onFinishChange(currentValue); }\r\n            }\r\n\r\n        };\r\n        const onBlur = () => onDoneEditing(); // The user is done editing this cell (usually means they clicked elsewhere)\r\n        const onKeyDown = (ev: React.KeyboardEvent<HTMLInputElement>) => {\r\n            if(ev.key === 'Enter') {\r\n                onDoneEditing();\r\n            } else if(ev.key === 'Esc') {\r\n                onDoneEditing(true);\r\n            }\r\n        };\r\n\r\n        return <input className={classNames(editingClassName)} type=\"text\" value={currentValue} onKeyDown={onKeyDown} onChange={onChange} onBlur={onBlur} placeholder={placeholder} ref={inputRef}></input>\r\n    } else {\r\n        // When the user clicks, begin editing\r\n        const onClick = () => {\r\n            if(editable) {\r\n                setState(STATE.EDITING);\r\n                setBeforeEditValue(currentValue); // track what the value was before\r\n                if(onStartEditing)  { onStartEditing(); }\r\n            }\r\n        };\r\n        const usePlaceholder = !currentValue.trim(); // If the user hasn't entered anything, we need to use the placeholder\r\n\r\n        return <button disabled={!editable} className={classNames('btn', 'btn-link', viewingClassName, {placeholder: usePlaceholder})} onClick={onClick}>{usePlaceholder ? (placeholder || '(empty)') : currentValue}</button>\r\n    }\r\n}\r\n\r\nexport default EditableTextField;","import React, { useState } from \"react\";\r\n\r\n/**\r\n * A widget for configuring the lemon timer\r\n */\r\n\r\nexport type IntervalConfigProps = {\r\n    workInterval: number, // How long a work interval should be (usually in minutes)\r\n    breakInterval: number, // How long a break interval should be (usually in minutes)\r\n    onChangeWorkInterval: (newWorkInterval: number) => void, // A callback to be called when the user changes the work interval\r\n    onChangeBreakInterval: (newBreakInterval: number) => void, // A callback to be called when the user changes the break interval\r\n}\r\n\r\nconst IntervalConfigDisplay: React.FC<IntervalConfigProps> = ({workInterval: initialWorkInterval, breakInterval: initialBreakInterval, onChangeWorkInterval, onChangeBreakInterval }) => {\r\n    const [workInterval,  setWorkInterval]  = useState(initialWorkInterval);  // Current value for work interval\r\n    const [breakInterval, setBreakInterval] = useState(initialBreakInterval); // Current value for break interval\r\n\r\n    const onWorkIntervalChange = (ev: React.ChangeEvent<HTMLInputElement>) => {\r\n        const newValue = parseInt(ev.target.value);\r\n        setWorkInterval(newValue);\r\n        onChangeWorkInterval(newValue);\r\n    };\r\n\r\n    const onBreakIntervalChange = (ev: React.ChangeEvent<HTMLInputElement>) => {\r\n        const newValue = parseInt(ev.target.value);\r\n        setBreakInterval(newValue);\r\n        onChangeBreakInterval(newValue);\r\n    };\r\n\r\n    return <form className=\"form-inline row\">\r\n                <div className=\"col-md-3\" />\r\n                <div className=\"col-md-3\">\r\n                    <label htmlFor=\"work-len\">work interval (minutes):</label>\r\n                    <input className=\"form-control\" min={1} max={2*60} type=\"number\" id=\"work-len\" value={workInterval||''} onChange={onWorkIntervalChange}></input>\r\n                </div>\r\n                <div className=\"col-md-3\">\r\n                    <label htmlFor=\"break-len\">break interval (minutes):</label>\r\n                    <input className=\"form-control\" min={1} max={2*60} type=\"number\" id=\"break-len\" value={breakInterval||''} onChange={onBreakIntervalChange}></input>\r\n                </div>\r\n                <div className=\"col-md-3\" />\r\n            </form>;\r\n};\r\n\r\nexport default IntervalConfigDisplay;","import React, { useEffect, useState } from \"react\";\r\n\r\ntype CountdownTimerDisplayProps = {\r\n    target: number,     // The timestamp that we are counting to\r\n    onDone: () => void, // A callback when we have completed the countdown\r\n}\r\n\r\nconst CountdownTimerDisplay: React.FC<CountdownTimerDisplayProps> = ({target, onDone}) => {\r\n    const [remaining, setRemaining] = useState<number>(target - Date.now());\r\n    useEffect(() => {\r\n        const updateInterval = setInterval(() => {\r\n            const timeLeft = target - Date.now();\r\n            setRemaining(timeLeft);\r\n\r\n            if(timeLeft <= 0) {\r\n                clearInterval(updateInterval);\r\n                onDone();\r\n            }\r\n        }, 1000);\r\n\r\n        return () => clearInterval(updateInterval); // Cleanup function\r\n    }, []);\r\n\r\n    return <>{millisecondsToHumanString(remaining)}</>;\r\n};\r\n\r\n/**\r\n * This function converts a number of milliseconds into \"human\" time\r\n * \r\n * @param ms The number of milliseconds\r\n * @returns A string of the form MM:ss (MM represents minutes, ss represents seconds)\r\n */\r\nexport function millisecondsToHumanString(ms: number): string {\r\n    const totalSeconds = Math.round(ms/1000); // Convert millseconds to seconds\r\n\r\n    const minutes = Math.floor(totalSeconds/60).toString().padStart(2, '0'); // padStart to ensure that if it's <10, we still display a leading 0\r\n    const seconds = (totalSeconds%60).toString().padStart(2, '0'); // padStart to ensure we have a leading 0\r\n    return `${minutes}:${seconds}`;\r\n}\r\n\r\nexport default CountdownTimerDisplay;","import React, { useEffect, useState } from \"react\";\r\nimport IntervalConfigDisplay from \"./IntervalConfig\";\r\nimport TaskDisplay  from \"./TaskDisplay\";\r\nimport CountdownTimerDisplay  from \"./Timer\";\r\nimport update from 'immutability-helper';\r\nimport classNames from \"classnames\";\r\n\r\n/**\r\n * The primary application container\r\n */\r\n\r\nconst MS_PER_MINUTE = 60 * 1000; // Milliseconds per minute\r\n\r\nconst MTaskDisplay = React.memo(TaskDisplay); // Memoize the TaskDisplay component to avoid unnecessary re-rendering\r\n\r\nexport enum STOP_REASON { USER_INTERRUPT, COMPLETED } // Encodes *why* a timer was stopped (whether it finished or the user manually hit stop)\r\n\r\ntype AppProps = {\r\n    state: AppState,                     // Optionally pass in an initial state\r\n    onStateChange?: (state: AppState) => void   // A callback to be called when the state changes\r\n}\r\n\r\nexport type AppState = { // (no, not the school)\r\n    tasks: Array<Task>,         // The list of tasks\r\n    workInterval: number,       // How long work intervals should be (in minutes)\r\n    breakInterval: number,      // How long break intervals should be (in minutes)\r\n    activeTaskID: number|false, // false: no active task. Otherwise, the ID of the active task\r\n    workingUntil: number|false, // false: no active task. Otherwise, the timestamp at which this work session ends\r\n    onBreakUntil: number|false  // false: not on break.   Otherwise, the timestamp at which the break ends\r\n}\r\n\r\nexport type Task = { // Represents a single task\r\n    id: number,                // A unique ID for the task\r\n    description: string,       // A description of the task\r\n    completedIntervals: number // How many times we have worked on this task (how many lemons)\r\n}\r\nconst pingAudio = new Audio('ping.wav');\r\n\r\n\r\nlet editingTaskUid: number|false = false; // When we first create a new task, we want to start editing it. This variable tracks the last task we created (so that we know to edit it)\r\nconst App: React.FC<AppProps> = ({ state: initialState, onStateChange }) => {\r\n    const [state, setState] = useState<AppState>(initialState); // If the user did not pass in an initial state, use the defaults\r\n\r\n    useEffect(() => { // Whenever the state changes, call the appropriate callback\r\n        if(onStateChange) {\r\n            onStateChange(state);\r\n        }\r\n    }, [state]);\r\n\r\n    const addTask = React.useCallback(() => { // When the user adds a new task\r\n        setState((state) => {\r\n            // Come up with a new unique id by taking the maximum of existing IDs...\r\n            const maxExistingID = Math.max(0, ...state.tasks.map((t) => t.id));\r\n            const id = editingTaskUid = maxExistingID + 1; // ... and adding 1\r\n\r\n            const newTask: Task = {id, description: '', completedIntervals: 0}; // The new task object to be pushed\r\n            return update(state, { tasks: {$push: [newTask]}});\r\n        });\r\n    }, []);\r\n\r\n    const startTask = React.useCallback((id: number) => { // When the user starts a task\r\n        setState((state) => {\r\n            const workingUntil = Date.now() + (state.workInterval||0) * MS_PER_MINUTE; // The timestamp at which we've completed working on the task\r\n            return update(state, { activeTaskID: {$set: id}, workingUntil: {$set: workingUntil} });\r\n        });\r\n    }, []);\r\n\r\n    const stopTask = React.useCallback((id: number, reason: STOP_REASON) => { // When the user stops a task (whether manually or because the timer completed)\r\n        setState((state) => {\r\n            if(reason === STOP_REASON.COMPLETED) { // If we stopped because we actually finished the task\r\n                pingAudio.play();\r\n                const taskIndex = getTaskIndex(state.tasks, id);\r\n                if(taskIndex!==false) {\r\n                    // Add one more completed interval, remove the tactive task ID, mark that we're on break\r\n                    const breakUntil = Date.now() + (state.breakInterval||0) * MS_PER_MINUTE;\r\n                    return update(state, { activeTaskID: {$set: false}, workingUntil: {$set: false}, onBreakUntil: {$set: breakUntil}, tasks: { [taskIndex]: { completedIntervals: {$apply: (c) => c+1}}}});\r\n                }\r\n            }\r\n            // If the user cancelled, just set the active task to false (don't add another completed stamp and don't go on break)\r\n            return update(state, { activeTaskID: {$set: false}, workingUntil: {$set: false} });\r\n        });\r\n    }, []);\r\n\r\n    const removeTask = React.useCallback((id: number) => { // Delete a task\r\n        setState((state) => {\r\n            const taskIndex = getTaskIndex(state.tasks, id); // get the task index...\r\n            if(taskIndex!==false) {\r\n                return update(state, {tasks: {$splice: [[taskIndex, 1]]}}); //...and remove it\r\n            } else {\r\n                return state;\r\n            }\r\n        });\r\n    }, []);\r\n\r\n    const setTaskDescription = React.useCallback((id: number, description: string) => { // Change a task description\r\n        setState((state) => {\r\n            const taskIndex = getTaskIndex(state.tasks, id);\r\n            if(taskIndex!==false) {\r\n                return update(state, {tasks: {[taskIndex]: { description: {$set: description }}}});\r\n            } else {\r\n                return state;\r\n            }\r\n        });\r\n    }, []);\r\n\r\n    const setWorkInterval = React.useCallback((newWorkInterval: number) => { // Change how long each work interval is\r\n        setState((state) => {\r\n            return update(state, {workInterval: {$set: newWorkInterval}});\r\n        });\r\n    }, []);\r\n\r\n    const setBreakInterval = React.useCallback((newBreakInterval: number) => { // Change how long each break interval is\r\n        setState((state) => {\r\n            return update(state, {breakInterval: {$set: newBreakInterval}});\r\n        });\r\n    }, []);\r\n\r\n    const stopBreak = (reason: STOP_REASON) => { // When the user interrupts the break\r\n        setState((state) => {\r\n            if(reason === STOP_REASON.COMPLETED) { // Only play the ping if the user did *not interrupt*\r\n                pingAudio.play();\r\n            }\r\n            return update(state, {onBreakUntil: {$set: false}})\r\n        });\r\n    };\r\n\r\n    const currentlyWorking = state.activeTaskID !== false;\r\n    const currentlyOnBreak = state.onBreakUntil !== false;\r\n    const currentlyIdle    = !currentlyWorking && !currentlyOnBreak;\r\n\r\n    const taskElements = state.tasks.map((t) => {\r\n        const isActiveTask = t.id === state.activeTaskID;\r\n        const editable = (state.activeTaskID===false) && (state.onBreakUntil === false);\r\n        return <MTaskDisplay key={t.id} onStop={stopTask} onStart={startTask} task={t} editing={t.id===editingTaskUid} onRemove={removeTask} onDescriptionChange={setTaskDescription} workOnUntil={isActiveTask && state.workingUntil} editable={editable}  />\r\n    });\r\n    editingTaskUid = false; // Ensure that we aren't going to auto-edit the next task on start\r\n\r\n    return <>\r\n    <main className=\"container\">\r\n        <table id=\"lemon-app\" className={classNames('table', {working: currentlyWorking})}>\r\n            <thead>\r\n                <tr>\r\n                    <th colSpan={3} className = {classNames({invisible: currentlyWorking})}>\r\n                        {!currentlyOnBreak  && <h1>what do you want to do?</h1>}\r\n                        {state.onBreakUntil && <h1>take a break&nbsp;\r\n                                <CountdownTimerDisplay target={state.onBreakUntil} onDone={() => stopBreak(STOP_REASON.COMPLETED)} />&nbsp;\r\n                                <button className=\"btn btn-outline-danger btn-block\"  onClick={() => stopBreak(STOP_REASON.USER_INTERRUPT)}><i className=\"fa-solid fa-stop\" />&nbsp;end break</button>\r\n                            </h1>}\r\n                    </th>\r\n                </tr>\r\n            </thead>\r\n            <tbody>{!currentlyOnBreak && taskElements}</tbody>\r\n            <tfoot>\r\n                <tr>\r\n                    <td colSpan={3}>\r\n                        <div className=\"d-grid\">\r\n                            {currentlyIdle && <button className=\"btn btn-primary btn-block\" disabled={state.activeTaskID!==false} onClick={addTask}><i className=\"fa-solid fa-plus\" />&nbsp;add task</button> }\r\n                        </div>\r\n                    </td>\r\n                </tr>\r\n            </tfoot>\r\n        </table>\r\n    </main>\r\n    <footer className=\"container\">\r\n        {currentlyIdle && <IntervalConfigDisplay workInterval={state.workInterval} breakInterval={state.breakInterval} onChangeWorkInterval={setWorkInterval} onChangeBreakInterval={setBreakInterval} /> }\r\n    </footer>\r\n    </>\r\n};\r\n\r\nexport default App;\r\n\r\n/**\r\n * Given a list of tasks, this function finds the task with the specified ID (or false if it could not find that task)\r\n * \r\n * @param tasks A list of tasks\r\n * @param id The ID of the task we are seraching for\r\n * @returns The task index (or false if we could not find the task)\r\n */\r\nexport function getTaskIndex(tasks: Array<Task>, id: number): number|false {\r\n    for(let idx: number = 0; idx<tasks.length; idx++) {\r\n        if(tasks[idx].id === id) {\r\n            return idx\r\n        }\r\n    }\r\n    return false;\r\n}","import classNames from \"classnames\";\r\nimport { useEffect, useState } from \"react\";\r\n\r\nexport type LemonIconProps = {\r\n    blinking?: boolean // if true, blink the lemon\r\n}\r\n\r\nconst LemonIcon: React.FC<LemonIconProps> = ({blinking}) => {\r\n    const [solid, setSolid] = useState<boolean>(true);\r\n\r\n    useEffect(() => {\r\n        if(blinking) {\r\n            const interval = setInterval(() => {\r\n                setSolid((s) => !s); // toggle whether solid\r\n            }, 500);\r\n            return () => { clearInterval(interval); } // return cleanup function\r\n        }\r\n    }, [blinking]);\r\n\r\n    return <i className={classNames('lemon', 'fa-lemon', solid ? 'fa-solid' : 'fa-regular')} />;\r\n}\r\nexport default LemonIcon;","import EditableTextField from \"./EditableTextField\"\r\nimport { times } from 'lodash';\r\nimport { useState } from \"react\";\r\nimport CountdownTimerDisplay from \"./Timer\";\r\nimport LemonIcon from \"./LemonIcon\";\r\nimport { STOP_REASON, Task } from \"./App\";\r\nimport classNames from \"classnames\";\r\n\r\n\r\n/**\r\n * Represents the display for an individual task\r\n */\r\n\r\nexport type TaskProps = {\r\n    task: Task,                                                          // The task we are displaying\r\n    editing: boolean,                                                    // If true, we edit the task description on load\r\n    onRemove: (id: number) => void,                                      // Callback for when the user requests to remove this task\r\n    onDescriptionChange: (id: number, description: string) => void,      // Callback for when the user requests to edit the task description\r\n    onStart: (id: number) => void,                                       // Callback for when the user requests to start the task\r\n    onStop: (id: number, reason: STOP_REASON) => void,                   // Callback for when the task stops (whether initiated by the user or completed)\r\n    workOnUntil: number|false,                                           // The timestamp that we're working on **this task** until (or false if we aren't working on this task)\r\n    editable: boolean                                                    // Whether the user should be able to edit/remove/start this task\r\n}\r\n\r\nconst TaskDisplay: React.FC<TaskProps> = ({task, editing, onRemove, onDescriptionChange, onStart, workOnUntil, editable, onStop}) => {\r\n    const [currentlyEditing, setCurrentlyEditing] = useState<boolean>(editing); // Are we currently editing the description?\r\n    const lemonIcons = times(task.completedIntervals, (idx) => <LemonIcon blinking={false} key={idx} />); // Show the appropriate number of lemon icons\r\n\r\n    return <tr className={\"task\" + (workOnUntil ? ' active' : '')}>\r\n        <td className=\"input-group\" style={{minWidth: '25em'}}>\r\n            <EditableTextField editable={editable} onStartEditing={() => setCurrentlyEditing(true)} onStopEditing={() => setCurrentlyEditing(false)} editingClassName={'form-control'} value={task.description} editing={editing} placeholder='Task description' onFinishChange={(desc) => onDescriptionChange(task.id, desc)} />\r\n            {currentlyEditing && <button className=\"btn btn-outline-danger btn-sm\" onMouseDown={() => onRemove(task.id)}><i className=\"fa-regular fa-trash-can\" /></button>}\r\n        </td>\r\n        <td className=\"completedCount align-middle\" style={{width: '100%'}}>\r\n            <div className=\"py-1\">\r\n                {lemonIcons}\r\n                {workOnUntil && <><LemonIcon blinking={true} key={lemonIcons.length} />&nbsp;<span className=\"lemon-timer\"><CountdownTimerDisplay target={workOnUntil} onDone={() => onStop(task.id, STOP_REASON.COMPLETED)} /></span></>}\r\n            </div>\r\n        </td>\r\n        <td className=\"d-grid\" style={{width: '15em'}}>\r\n            {workOnUntil  && <button className=\"btn btn-outline-danger btn-block\"  onClick={() => onStop(task.id, STOP_REASON.USER_INTERRUPT)}><i className=\"fa-solid fa-stop\" />&nbsp;stop</button>}\r\n            {!workOnUntil && <button className={classNames('btn', 'btn-outline-success', 'btn-block', {invisible: !editable})} onClick={() => onStart(task.id)}><i className=\"fa-solid fa-play\" />&nbsp;start</button> }\r\n        </td>\r\n    </tr>\r\n}\r\n\r\n\r\nexport default TaskDisplay;","import ReactDOM from 'react-dom';\nimport App, { AppState, getTaskIndex } from './App';\n\nimport 'bootstrap/dist/css/bootstrap.css'; // bootstrap (https://getbootstrap.com/) has layout controls\nimport '@fortawesome/fontawesome-free/css/all.css'; // fontAwesome (https://fontawesome.com/) has icons\nimport './index.scss';\nimport { useEffect, useState } from 'react';\nimport { millisecondsToHumanString } from './Timer';\nimport { Helmet } from 'react-helmet';\nimport React from 'react';\n\n\nconst DEFAULT_TITLE = 'SI 579 PS 7';     // The window title when idle\nconst LOCAL_STORAGE_KEY = 'lemon_timer'; // The key in localStorage that we save everything to.\n\n\nconst DEFAULT_APP_STATE: AppState = { // When we start with no current application state, these are our defaults\n    tasks: [], activeTaskID: false, workingUntil: false, onBreakUntil: false,\n    workInterval: 25, breakInterval: 5\n};\n\n\n// Save the current state to localStorage\nfunction saveState(state: AppState) {\n    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(state));\n}\n\n// Load the state from localStorage (or return false if we couldn't find it)\nfunction loadState(): AppState|false {\n    try {\n        const data = localStorage.getItem(LOCAL_STORAGE_KEY);\n        if(data) {\n            return JSON.parse(data);\n        } else {\n            return false;\n        }\n    } catch {\n        return false; // probably an error parsing the JSON\n    }\n}\n\nconst MApp = React.memo(App);\n\nfunction Root() {\n    const [state, setAppState] = useState<AppState>(loadState() || DEFAULT_APP_STATE)\n    const [title, setTitle] = useState<string>(DEFAULT_TITLE);\n\n    useEffect(() => { // Update the window title to reflect the current task\n        const updateInterval = setInterval(() => {\n            if(state.workingUntil !== false && state.activeTaskID !== false) { // The user is in a work session\n                const remaining = state.workingUntil - Date.now();\n                const humanReadableRemaining = millisecondsToHumanString(remaining);\n\n                const taskIndex = getTaskIndex(state.tasks, state.activeTaskID);\n                const taskDescription = taskIndex === false ? 'focus' : state.tasks[taskIndex].description;\n                setTitle(`${humanReadableRemaining} - ${taskDescription}`);\n            } else if(state.onBreakUntil !== false) { // The user is on break\n                const remaining = state.onBreakUntil - Date.now();\n                setTitle(`${millisecondsToHumanString(remaining)} - Break`);\n            } else {\n                if(title !== DEFAULT_TITLE) {\n                    setTitle(DEFAULT_TITLE);\n                }\n            }\n        }, 1000);\n\n        return () => clearInterval(updateInterval); // Cleanup function\n    }, [state]);\n\n    const onStateChange = React.useCallback((newState: AppState) => {\n        setAppState(newState);\n        saveState(newState);\n    }, []);\n\n    return <>\n        <Helmet><title>{title}</title></Helmet>\n        <MApp onStateChange={onStateChange} state={state} />\n    </>\n}\n\nReactDOM.render(<Root />, document.getElementById('root'));\n"],"sourceRoot":""}